<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <script>
    if (screen.orientation && screen.orientation.lock) {
      screen.orientation.lock("portrait").catch(() => {});
    }
  </script>
  <title>Draw App</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #fefaf6;
      font-family: sans-serif;
    }

    #toolbar {
      position: fixed;
      bottom: 0; left: 0; right: 0;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
      padding: 8px 6px;
      background: rgba(232,228,223,0.9);
      box-shadow: 0 -2px 4px rgba(0,0,0,0.2);
      border-radius: 12px 12px 0 0;
      z-index: 10;
      transition: opacity 0.5s;
    }

    #toolbar input,
    #toolbar button,
    #toolbar select {
      font-size: 16px;
      padding: 6px 10px;
      background: #d5e3dc;
      border: none;
      border-radius: 10px;
    }

    #toolbar button {
      background: #e3daf5;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    #quickPalette {
      display: flex;
      gap: 4px;
    }
    .swatch {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 1px solid #00000030;
      cursor: pointer;
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      touch-action: none; /* –æ—Ç–∫–ª—é—á–∞–µ–º –±—Ä–∞—É–∑–µ—Ä–Ω—ã–π –∑—É–º/—Å–∫—Ä–æ–ª–ª –ø—Ä–∏ —Ä–∏—Å–æ–≤–∞–Ω–∏–∏ */
    }

    .snapshot {
      position: fixed;
      left: 50%;
      bottom: 20px;
      width: 160px;
      transform: translateX(-50%);
      box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      animation: polaroid 3s ease-out forwards;
      border-radius: 4px;
    }

    @keyframes polaroid {
      from { transform: translate(-50%,100%); opacity: 0; }
      30%  { opacity: 1; }
      to   { transform: translate(-50%,20px); opacity: 0; }
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <input type="color" id="colorPicker" title="–¶–≤–µ—Ç –∫–∏—Å—Ç–∏" value="#000000">
    <label title="–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å">
      <input type="range" id="opacityPicker" min="0" max="100" value="100">
    </label>
    <label title="–†–∞–∑–º–µ—Ä –∫–∏—Å—Ç–∏">
      <input type="range" id="sizePicker" min="1" max="50" value="5">
    </label>
    <select id="brushShape" title="–¢–∏–ø –∫–∏—Å—Ç–∏">
      <option value="round">–ö—Ä—É–≥–ª–∞—è</option>
      <option value="square">–ö–≤–∞–¥—Ä–∞—Ç–Ω–∞—è</option>
      <option value="eraser">–õ–∞—Å—Ç–∏–∫</option>
    </select>
    <button id="zoomInBtn"  title="–ü—Ä–∏–±–ª–∏–∑–∏—Ç—å">+</button>
    <button id="zoomOutBtn" title="–û—Ç–¥–∞–ª–∏—Ç—å">-</button>
    <button id="undoBtn" title="–û—Ç–º–µ–Ω–∏—Ç—å">&#8617;</button>
    <button id="redoBtn" title="–ü–æ–≤—Ç–æ—Ä–∏—Ç—å">&#8618;</button>
    <button id="fillBtn" title="–ó–∞–ª–∏–≤–∫–∞">–ó–∞–ª–∏—Ç—å</button>
    <button id="eyedropperBtn" title="–ü–∏–ø–µ—Ç–∫–∞">–ü–∏–ø–µ—Ç–∫–∞</button>
    <button id="clearBtn">–û—á–∏—Å—Ç–∏—Ç—å</button>
    <button id="saveBtn">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
    <button id="ambientBtn" title="–ó–≤—É–∫">üéµ</button>
    <div id="quickPalette" title="–ë—ã—Å—Ç—Ä—ã–µ —Ü–≤–µ—Ç–∞"></div>
    <select id="layerSelect" title="–°–ª–æ–π">
      <option value="1">–û–±—ä–µ–∫—Ç—ã</option>
      <option value="0">–§–æ–Ω</option>
    </select>
    <label><input type="checkbox" id="showLayer0" checked>–§–æ–Ω</label>
    <label><input type="checkbox" id="showLayer1" checked>–û–±—ä–µ–∫—Ç—ã</label>
  </div>
  <canvas id="layer0"></canvas>
  <canvas id="layer1"></canvas>

  <script>
    const toolbar = document.getElementById('toolbar');
    const layers = [
      document.getElementById('layer0'),
      document.getElementById('layer1')
    ];
    const ctxs = layers.map(l => l.getContext('2d'));
    let activeLayer = 1;
    let canvas = layers[activeLayer];
    let ctx    = ctxs[activeLayer];

    const colorPicker  = document.getElementById('colorPicker');
    const opacityPicker= document.getElementById('opacityPicker');
    const sizePicker   = document.getElementById('sizePicker');
    const brushShape   = document.getElementById('brushShape');
    const zoomInBtn    = document.getElementById('zoomInBtn');
    const zoomOutBtn   = document.getElementById('zoomOutBtn');
    const undoBtn      = document.getElementById('undoBtn');
    const redoBtn      = document.getElementById('redoBtn');
    const fillBtn      = document.getElementById('fillBtn');
    const eyedropperBtn= document.getElementById('eyedropperBtn');
    const clearBtn     = document.getElementById('clearBtn');
    const saveBtn      = document.getElementById('saveBtn');
    const ambientBtn   = document.getElementById('ambientBtn');
    const quickPalette = document.getElementById('quickPalette');
    const layerSelect  = document.getElementById('layerSelect');
    const showLayer0   = document.getElementById('showLayer0');
    const showLayer1   = document.getElementById('showLayer1');

    const paletteColors = ['#000000','#ff0000','#00ff00','#0000ff','#ffff00','#ff00ff','#00ffff','#ffffff'];
    quickPalette.innerHTML = paletteColors.map(c => `<div class="swatch" data-color="${c}" style="background:${c}"></div>`).join('');
    quickPalette.addEventListener('click', e => {
      if (e.target.classList.contains('swatch')) {
        colorPicker.value = e.target.dataset.color;
      }
    });

    function updateVisibility() {
      layers[0].style.display = showLayer0.checked ? 'block' : 'none';
      layers[1].style.display = showLayer1.checked ? 'block' : 'none';
    }
    showLayer0.addEventListener('change', updateVisibility);
    showLayer1.addEventListener('change', updateVisibility);
    layerSelect.addEventListener('change', () => {
      activeLayer = parseInt(layerSelect.value, 10);
      canvas = layers[activeLayer];
      ctx = ctxs[activeLayer];
    });
    updateVisibility();

    let currentTool = 'brush';
    const history = [];
    const redoStack = [];

    let scale = 1;
    let rotation = 0;
    let startAngle = 0;
    let startRotation = 0;

    let drawing = false;
    const pointers = new Map();
    let pinching = false;
    let startDistance = 0;
    let startScale = 1;

    function hexToRGBA(hex, alpha) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r},${g},${b},${alpha})`;
    }

    function getCanvasCoords(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left) / scale,
        y: (e.clientY - rect.top) / scale
      };
    }

    function autosave() {
      layers.forEach((l, i) => {
        try { localStorage.setItem('layer'+i, l.toDataURL()); } catch(e) {}
      });
    }

    function saveState() {
      history.push(canvas.toDataURL());
      if (history.length > 50) history.shift();
      redoStack.length = 0;
      autosave();
    }

    function restoreState(data) {
      const img = new Image();
      img.onload = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0);
      };
      img.src = data;
    }

    function resizeCanvas() {
      layers.forEach(layer => {
        layer.width  = window.innerWidth;
        layer.height = window.innerHeight - toolbar.offsetHeight;
        layer.style.top = '0';
      });
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    layers.forEach((layer, i) => {
      const data = localStorage.getItem('layer'+i);
      if (data) {
        const img = new Image();
        img.onload = () => ctxs[i].drawImage(img, 0, 0);
        img.src = data;
      }
    });
    saveState();

    ctx.lineCap   = 'round';
    ctx.lineJoin  = 'round';

    function distance(a, b) {
      return Math.hypot(a.x - b.x, a.y - b.y);
    }

    function angle(a, b) {
      return Math.atan2(b.y - a.y, b.x - a.x);
    }

    function startDrawing(e) {
      drawing = true;
      ctx.strokeStyle = hexToRGBA(colorPicker.value, opacityPicker.value / 100);
      ctx.lineWidth   = sizePicker.value;
      if (brushShape.value === 'eraser') {
        ctx.globalCompositeOperation = 'destination-out';
      } else {
        ctx.globalCompositeOperation = 'source-over';
      }
      if (brushShape.value === 'square') {
        ctx.lineCap = ctx.lineJoin = 'butt';
      } else {
        ctx.lineCap = ctx.lineJoin = 'round';
      }
      ctx.beginPath();
      const pos = getCanvasCoords(e);
      ctx.moveTo(pos.x, pos.y);
      canvas.setPointerCapture(e.pointerId);
    }

    function pointerDown(e) {
      pointers.set(e.pointerId, {x: e.clientX, y: e.clientY});
      if (pointers.size === 2) {
        pinching = true;
        const [p1, p2] = Array.from(pointers.values());
        startDistance = distance(p1, p2);
        startScale = scale;
        startAngle = angle(p1, p2);
        startRotation = rotation;
        if (drawing) {
          drawing = false;
          ctx.closePath();
        }
        return;
      }
      if (pointers.size > 1 || pinching) return;

      if (e.currentTarget !== canvas) {
        pointers.delete(e.pointerId);
        return;
      }

      if (currentTool === 'eyedropper') {
        const pos = getCanvasCoords(e);
        const data = ctx.getImageData(pos.x, pos.y, 1, 1).data;
        const hex = '#' + [data[0], data[1], data[2]].map(v => v.toString(16).padStart(2, '0')).join('');
        colorPicker.value = hex;
        opacityPicker.value = Math.round(data[3] / 255 * 100);
        currentTool = 'brush';
        pointers.delete(e.pointerId);
        return;
      }

      startDrawing(e);
    }

    function pointerMove(e) {
      if (pinching) {
        if (pointers.has(e.pointerId)) {
          pointers.set(e.pointerId, {x: e.clientX, y: e.clientY});
          if (pointers.size === 2) {
            const [p1, p2] = Array.from(pointers.values());
            const newDist = distance(p1, p2);
            scale = startScale * newDist / startDistance;
            const newAngle = angle(p1, p2);
            rotation = startRotation + newAngle - startAngle;
            updateTransform();
          }
        }
        return;
      }
      if (!drawing) return;
      const pos = getCanvasCoords(e);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
    }

    function pointerUp(e) {
      if (pinching) {
        pointers.delete(e.pointerId);
        if (pointers.size < 2) {
          pinching = false;
        }
        return;
      }
      if (!drawing) return;
      drawing = false;
      ctx.closePath();
      ctx.globalCompositeOperation = 'source-over';
      canvas.releasePointerCapture(e.pointerId);
      saveState();
      pointers.delete(e.pointerId);
    }

    layers.forEach(layer => {
      layer.addEventListener('pointerdown', pointerDown);
      layer.addEventListener('pointermove', pointerMove);
      layer.addEventListener('pointerup',   pointerUp);
      layer.addEventListener('pointerout',  pointerUp);
      layer.addEventListener('pointercancel', pointerUp);
    });

    clearBtn.addEventListener('click', () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      saveState();
    });

    undoBtn.addEventListener('click', () => {
      if (history.length > 0) {
        redoStack.push(canvas.toDataURL());
        const data = history.pop();
        restoreState(data);
      }
    });

    redoBtn.addEventListener('click', () => {
      if (redoStack.length > 0) {
        history.push(canvas.toDataURL());
        const data = redoStack.pop();
        restoreState(data);
      }
    });

    fillBtn.addEventListener('click', () => {
      ctx.fillStyle = hexToRGBA(colorPicker.value, opacityPicker.value / 100);
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      saveState();
    });

    eyedropperBtn.addEventListener('click', () => {
      currentTool = currentTool === 'eyedropper' ? 'brush' : 'eyedropper';
    });

    function updateTransform() {
      layers.forEach(layer => {
        layer.style.transformOrigin = '0 0';
        layer.style.transform = `scale(${scale}) rotate(${rotation}rad)`;
      });
    }

    zoomInBtn.addEventListener('click', () => {
      scale *= 1.2;
      updateTransform();
    });

    zoomOutBtn.addEventListener('click', () => {
      scale /= 1.2;
      updateTransform();
    });

    updateTransform();

    saveBtn.addEventListener('click', () => {
      const off = document.createElement('canvas');
      off.width = canvas.width;
      off.height = canvas.height;
      const offCtx = off.getContext('2d');
      layers.forEach(l => offCtx.drawImage(l, 0, 0));
      const url = off.toDataURL('image/png');
      const link = document.createElement('a');
      link.download = 'drawing.png';
      link.href = url;
      link.click();

      const img = document.createElement('img');
      img.src = url;
      img.className = 'snapshot';
      document.body.appendChild(img);
      setTimeout(() => img.remove(), 3000);
    });

    let audioCtx, noiseSource;
    function toggleAmbient() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) {
          data[i] = Math.random() * 2 - 1;
        }
        noiseSource = audioCtx.createBufferSource();
        const gain = audioCtx.createGain();
        gain.gain.value = 0.05;
        noiseSource.buffer = buffer;
        noiseSource.loop = true;
        noiseSource.connect(gain).connect(audioCtx.destination);
        noiseSource.start();
      } else {
        if (audioCtx.state === 'running') audioCtx.suspend();
        else audioCtx.resume();
      }
    }

    ambientBtn.addEventListener('click', toggleAmbient);
  </script>
</body>
</html>
